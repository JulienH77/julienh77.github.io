<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trajet optimisé depuis la DDT</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
  <style>
    #map { height: 100vh; }
    #fileInput {
      position: absolute;
      z-index: 999;
      background: white;
      padding: 10px;
      top: 10px;
      left: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <input type="file" id="fileInput" accept=".zip" />
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.min.js"></script>
  <script src="https://unpkg.com/shpjs@latest/dist/shp.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <script>
    const map = L.map('map').setView([48.11658678172929, 5.145034144067746], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19
    }).addTo(map);

    const ddtCoord = [48.11658678172929, 5.145034144067746];

    // Icônes personnalisées
    const startIcon = L.icon({
      iconUrl: 'https://static.vecteezy.com/ti/vecteur-libre/p1/9117074-ddt-logo-ddt-letter-ddt-letter-logo-design-initials-ddt-logo-linked-with-circle-and-uppercase-monogram-logo-ddt-typography-for-technology-business-and-real-marque-immobilier-vectoriel.jpg',
      iconSize: [30, 30],
      iconAnchor: [15, 15]
    });

    const stepIcon = L.icon({
      iconUrl: 'https://cdn-icons-png.flaticon.com/512/9356/9356230.png',
      iconSize: [25, 25],
      iconAnchor: [12, 12]
    });
      
    const gpsIcon = L.icon({
      iconUrl: 'https://images.freeimages.com/vme/images/3/5/357941/red_racing_car_top_view_preview?h=350',
      iconSize: [50, 25],
      iconAnchor: [20, 20]
    });

    // === TSP heuristique : Nearest Neighbor ===
    function solveTSPNearestNeighbor(coords) {
      if (coords.length <= 2) return coords;

      const visited = new Set();
      const route = [coords[0]];
      visited.add(0);

      while (route.length < coords.length) {
        const last = route[route.length - 1];
        let nearestIndex = null;
        let nearestDist = Infinity;

        for (let i = 1; i < coords.length; i++) {
          if (visited.has(i)) continue;
          const dist = turf.distance(
            turf.point([last[1], last[0]]),
            turf.point([coords[i][1], coords[i][0]]),
            { units: 'kilometers' }
          );
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestIndex = i;
          }
        }
        route.push(coords[nearestIndex]);
        visited.add(nearestIndex);
      }

      // Retour au départ
      route.push(coords[0]);
      return route;
    }

    // === GPS ===
    let gpsMarker = null;
    let gpsCircle = null;

    function updatePosition(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const accuracy = pos.coords.accuracy;
      const latlng = L.latLng(lat, lon);

      if (!gpsMarker) {
        gpsMarker = L.marker(latlng, { icon: gpsIcon })
          .addTo(map)
          .bindPopup("Ma position");

        gpsCircle = L.circle(latlng, {
          radius: accuracy,
          color: 'green',
          fillColor: 'green',
          fillOpacity: 0.2
        }).addTo(map);

        map.setView(latlng, 13);
      } else {
        gpsMarker.setLatLng(latlng);
        gpsCircle.setLatLng(latlng).setRadius(accuracy);
      }
    }

    function showError(error) {
      console.error("Erreur GPS :", error.message);
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(updatePosition, showError, {
        enableHighAccuracy: true,
        maximumAge: 5000,
        timeout: 10000
      });
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(evt) {
        const arrayBuffer = evt.target.result;
        shp(arrayBuffer).then(function(geojson) {
          if (!geojson.features || geojson.features.length === 0) {
            alert("Aucun point trouvé dans le fichier.");
            return;
          }

          const points = geojson.features
            .filter(f => f.geometry && f.geometry.type === "Point")
            .map(f => [f.geometry.coordinates[1], f.geometry.coordinates[0]]);

          if (points.length === 0) {
            alert("Pas de points valides dans le shapefile.");
            return;
          }

          if (points.length > 20) {
            if (!confirm("Le fichier contient plus de 20 points, le calcul peut être long. Continuer ?")) {
              return;
            }
          }

          const allCoords = [ddtCoord, ...points];
          const optimizedRoute = solveTSPNearestNeighbor(allCoords);
          const latLngWaypoints = optimizedRoute.map(coord => L.latLng(coord[0], coord[1]));

          if (window.routingControl) {
            map.removeControl(window.routingControl);
          }

          window.routingControl = L.Routing.control({
            waypoints: latLngWaypoints,
            createMarker: function(i, wp) {
              if (i === 0 || i === latLngWaypoints.length - 1) {
                return L.marker(wp.latLng, { icon: startIcon }).bindPopup(
                  i === 0 ? "Départ - DDT de Chaumont" : "Départ - DDT de Chaumont"
                );
              } else {
                return L.marker(wp.latLng, { icon: stepIcon }).bindPopup("Étape " + i);
              }
            },
            lineOptions: {
              styles: [{ color: 'blue', opacity: 0.8, weight: 5 }]
            },
            routeWhileDragging: false
          }).addTo(map);
            
            
            
            
            

          const bounds = L.latLngBounds(latLngWaypoints);
          map.fitBounds(bounds);
        }).catch(err => {
          console.error(err);
          alert("Erreur lors du traitement du fichier ZIP.");
        });
      };
      reader.readAsArrayBuffer(file);
    });
  </script>
</body>
</html>
