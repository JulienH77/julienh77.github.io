<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Globe interactif — jour / nuit / légende / lune</title>
<style>
  /* Page */
  html,body,#root { height:100%; margin:0; padding:0; }
  body {
    background: url('./starfield.jpg') no-repeat center center fixed; /* FOND DE PAGE seulement */
    background-size: cover;
    font-family: Arial, Helvetica, sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow: hidden;
  }
  #root { position:relative; width:100%; height:100%; }

  /* ECharts container */
  #globeContainer { position:absolute; left:0; top:0; right:0; bottom:0; z-index:1; }

  /* Toggle jour/nuit stylé */
  #toggle {
    position:absolute;
    top:14px; left:14px;
    width:100px; height:40px; border-radius:22px;
    background: linear-gradient(90deg,#ffe066 50%, #4a90e2 50%);
    box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    display:flex; align-items:center; justify-content:space-between;
    padding:4px; box-sizing:border-box;
    cursor:pointer; z-index:120; user-select:none;
  }
  #toggle.night { background: linear-gradient(90deg,#4a90e2 50%, #ffe066 50%); }
  #toggle svg { width:20px; height:20px; pointer-events:none; }
  #toggle .ball {
    position:absolute; top:4px; left:4px; width:32px; height:32px; border-radius:50%;
    background:#ffd54a; box-shadow:0 6px 16px rgba(255,213,74,0.28);
    transition:left .28s, box-shadow .28s, background .28s;
    z-index: 10;
  }
  #toggle.night .ball { left:64px; background:#f1d56d; box-shadow:0 8px 20px rgba(241,213,109,0.25); }

  /* Legend */
  #legend {
    position:absolute; top:14px; right:14px; z-index:120;
    background: rgba(255,255,255,0.92); padding:10px 12px; border-radius:10px;
    box-shadow:0 6px 18px rgba(0,0,0,0.18); min-width:170px;
  }
  #legend label { display:flex; align-items:center; gap:10px; font-weight:700; color:#111; cursor:pointer; margin-bottom:8px; }
  #legend input[type=checkbox] { width:16px; height:16px; cursor:pointer; }

  /* Moon preview */
  #moonPreview { position:absolute; right:14px; bottom:14px; width:140px; height:140px; border-radius:50%; overflow:hidden; z-index:110; box-shadow:0 10px 30px rgba(0,0,0,0.6); background:#000; }

  /* helper text */
  #hint { position:absolute; left:14px; bottom:14px; z-index:120; color:white; text-shadow:0 1px 3px rgba(0,0,0,0.75); font-size:13px; }
</style>

<!-- ECharts libs -->
<script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts-gl@2/dist/echarts-gl.min.js"></script>
</head>
<body>
  <div id="root">
    <div id="globeContainer"></div>

    <div id="toggle" role="button" aria-pressed="false" aria-label="Basculer jour nuit">
      <svg class="sun" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5" fill="#FFD43B"/></svg>
      <svg class="moon" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 0112.21 3 7 7 0 1021 12.79z" fill="#FFDD66"/></svg>
      <div class="ball" aria-hidden="true"></div>
    </div>

    <div id="legend" role="group" aria-label="Contrôles des couches">
      <label><input id="chkPays" type="checkbox"> Limites (Pays)</label>
      <label><input id="chkTrajets" type="checkbox"> Trajets</label>
      <label><input id="chkCapitales" type="checkbox"> Capitales</label>
    </div>

    <div id="moonPreview" title="Aperçu Lune"></div>

    <div id="hint">Les couches sont décochées au démarrage — active-les via la légende.</div>
  </div>

<script>
(async function(){

  /* ---------- PATHS (locaux) ---------- */
  const PATH_DAY = './earth.jpg';
  const PATH_NIGHT_RAW = './night.jpg';
  const PATH_MOON_BASE = './moon-base.jpg';
  const PATH_MOON_BUMP = './moon-bump.jpg';
  const PATH_COUNTRIES = './countries_10m_new.geojson';
  const PATH_TRAJETS = './ALLLINE_TRAJET_wgs.geojson';
  const PATH_CAPITALS = './capitals.geojson';

  /* ---------- PARAMETERS ---------- */
  const INITIAL_TARGET = [10,50]; // centre Europe for initial view
  const INITIAL_DISTANCE = 140;
  const ROTATE_SPEED = 0.25; // very slow
  const CAPITALS_Z = 0; // place capitals on surface (no auto-zoom logic)

  /* ---------- HELPERS ---------- */
  function loadJSON(url){
    return fetch(url).then(r=>{ if(!r.ok) throw new Error(url+' '+r.status); return r.json(); });
  }
  function loadImage(url){ return new Promise((res,rej)=>{ const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=rej; i.src=url; }); }
  function tintToYellow(img,intensity=0.6){
    const w = img.naturalWidth||img.width, h = img.naturalHeight||img.height;
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,w,h);
    ctx.globalCompositeOperation='multiply';
    ctx.fillStyle = `rgba(241,213,109,${intensity})`;
    ctx.fillRect(0,0,w,h);
    ctx.globalCompositeOperation='destination-over';
    return c.toDataURL('image/jpeg',0.9);
  }

  function polygonToRings(geom){
    const lines = [];
    if(!geom) return lines;
    if(geom.type === 'Polygon'){
      geom.coordinates.forEach(ring => lines.push(ring.map(c=>[c[0],c[1]])));
    } else if(geom.type === 'MultiPolygon'){
      geom.coordinates.forEach(polygon => polygon.forEach(ring => lines.push(ring.map(c=>[c[0],c[1]]))));
    }
    return lines;
  }
  function featureToLines(feature){
    const geom = feature.geometry; const out=[];
    if(!geom) return out;
    if(geom.type === 'LineString') out.push(geom.coordinates.map(c=>[c[0],c[1]]));
    else if(geom.type === 'MultiLineString') geom.coordinates.forEach(l=>out.push(l.map(c=>[c[0],c[1]])));
    else if(geom.type === 'Polygon' || geom.type === 'MultiPolygon') polygonToRings(geom).forEach(l=>out.push(l));
    return out;
  }

  /* ---------- PRELOAD & PREPARE ---------- */
  // load & tint night texture (base64) to turn white -> warm yellow
  let dayTexture = PATH_DAY;
  let nightTexture = PATH_NIGHT_RAW;
  try {
    const nightImg = await loadImage(PATH_NIGHT_RAW);
    nightTexture = tintToYellow(nightImg, 0.6);
  } catch(e){
    console.warn('Impossible de teinter night.jpg; utilisation brute.', e);
    nightTexture = PATH_NIGHT_RAW;
  }

  // load geojsons
  let countriesGeo, trajetsGeo, capitalsGeo;
  try {
    [countriesGeo, trajetsGeo, capitalsGeo] = await Promise.all([
      loadJSON(PATH_COUNTRIES),
      loadJSON(PATH_TRAJETS),
      loadJSON(PATH_CAPITALS)
    ]);
  } catch(e){
    console.error('Erreur chargement geojsons', e);
    alert('Erreur chargement geojsons (voir console).');
    return;
  }

  // robust conversion -> arrays of line coords
  const countryLines = [];
  (countriesGeo.features||[]).forEach(f=>{
    polygonToRings(f.geometry).forEach(r=>countryLines.push({ coords: r.map(c=>[c[0],c[1], 0.8]), lineStyle:{ color:'#ffffff', width:1, opacity:1 } }));
  });

  // trajets (decompose multi)
  const mapColor = { 'avion':'#e11d48', 'train':'#06b6d4', 'bus':'#f97316', 'velo':'#10b981' };
  const trajetLines = [];
  (trajetsGeo.features||[]).forEach(f=>{
    const prop = (f.properties && (f.properties.trajet || f.properties.transport)) || '';
    const col = mapColor[(prop||'').toLowerCase()] || '#00ffff';
    if(f.geometry){
      if(f.geometry.type === 'LineString'){
        trajetLines.push({ coords: f.geometry.coordinates.map(c=>[c[0],c[1],1.6]), lineStyle:{ color:col, width:3, opacity:1 } });
      } else if(f.geometry.type === 'MultiLineString'){
        f.geometry.coordinates.forEach(line => trajetLines.push({ coords: line.map(c=>[c[0],c[1],1.6]), lineStyle:{ color:col, width:3, opacity:1 } }));
      } else {
        // fallback
        featureToLines(f).forEach(l=> trajetLines.push({ coords: l.map(c=>[c[0],c[1],1.6]), lineStyle:{ color:col, width:3, opacity:1 } }));
      }
    }
  });

  // capitals
  const capitalPoints = (capitalsGeo.features||[]).map(f=>({
    name: (f.properties && (f.properties.name || f.properties.NAME || '')),
    value: [f.geometry.coordinates[0], f.geometry.coordinates[1], CAPITALS_Z]
  }));

  /* ---------- CHARTS ---------- */
  const globeChart = echarts.init(document.getElementById('globeContainer'), null, { renderer:'webgl' });
  const moonChart = echarts.init(document.getElementById('moonPreview'), null, { renderer:'webgl' });

  /* ---------- STATE ---------- */
  let state = {
    showPays: false,
    showTrajets: false,
    showCapitales: false,
    isNight: false,
    distance: INITIAL_DISTANCE
  };

  let initialRenderDone = false; // to avoid re-centering after first render

  /* ---------- OPTION FACTORY ---------- */
  function makeOption(currentState, includeInitialTarget=false){
    const showBaseTexture = (!currentState.showPays) && (currentState.showTrajets || currentState.showCapitales);
    const baseTextureValue = showBaseTexture ? (currentState.isNight ? nightTexture : dayTexture) : null;

    const series = [];

    if(currentState.showPays){
      series.push({
        name:'Pays',
        type:'lines3D',
        coordinateSystem:'globe',
        blendMode:'normal',
        silent:true,
        lineStyle:{ width:1, opacity:1 },
        data: countryLines
      });
    }

    if(currentState.showTrajets){
      series.push({
        name:'Trajets',
        type:'lines3D',
        coordinateSystem:'globe',
        blendMode:'lighter',
        silent:true,
        lineStyle:{ width:3, opacity:1 },
        data: trajetLines
      });
    }

    if(currentState.showCapitales){
      series.push({
        name:'Capitales',
        type:'scatter3D',
        coordinateSystem:'globe',
        symbol:'circle',
        symbolSize:6,
        silent:true,
        itemStyle:{ color:'#ffffff', borderColor:'#000000', borderWidth:0.8 },
        data: capitalPoints
      });
    }

    // viewControl: include targetCoord only for initial render
    const viewControl = {
      distance: currentState.distance || INITIAL_DISTANCE,
      autoRotate: true,
      autoRotateSpeed: ROTATE_SPEED,
      minDistance: 50,
      maxDistance: 600,
      zoomSensitivity: 2,
      rotateSensitivity: 2
    };
    if(includeInitialTarget){
      viewControl.targetCoord = INITIAL_TARGET;
    }

    const opt = {
      backgroundColor: 'transparent',
      globe: {
        baseTexture: baseTextureValue || undefined,
        shading: 'lambert',
        environment: '#000000',
        light: { main:{ intensity:1.0 }, ambient:{ intensity:0.25 } },
        viewControl: viewControl,
        layers: [] // no clouds
      },
      series: series
    };
    return opt;
  }

  // initial render: include targetCoord once so we start centered on Europe
  globeChart.setOption(makeOption(state, true));
  initialRenderDone = true;

  // After a brief tick, capture actual distance then re-render without targetCoord to avoid forced recenter later
  setTimeout(()=> {
    try {
      const gcomp = globeChart.getModel().getComponent('globe');
      if(gcomp){
        let dist = INITIAL_DISTANCE;
        if(typeof gcomp.getViewControl === 'function'){
          const vc = gcomp.getViewControl();
          if(vc && typeof vc.distance === 'number') dist = vc.distance;
        } else if(gcomp.viewControl && typeof gcomp.viewControl.distance === 'number'){
          dist = gcomp.viewControl.distance;
        }
        state.distance = dist;
      }
    } catch(e){}
    globeChart.setOption(makeOption(state, false));
  }, 700);

  // moon preview: smaller and darker
  try {
    moonChart.setOption({
      backgroundColor: 'transparent',
      globe: {
        baseTexture: PATH_MOON_BASE,
        heightTexture: PATH_MOON_BUMP || undefined,
        shading: 'lambert',
        environment: '#000',
        light: { main:{ intensity:0.6 }, ambient:{ intensity:0.25 } },
        viewControl: { autoRotate:true, autoRotateSpeed:1.2, distance:120 }
      },
      series: []
    });
  } catch(e){
    console.warn('moon preview error', e);
  }

  /* ---------- UI BINDINGS ---------- */
  const toggleEl = document.getElementById('toggle');
  const chkPays = document.getElementById('chkPays');
  const chkTrajets = document.getElementById('chkTrajets');
  const chkCapitales = document.getElementById('chkCapitales');

  // ensure unchecked at start, day mode default
  chkPays.checked = false; chkTrajets.checked = false; chkCapitales.checked = false;
  toggleEl.classList.remove('night');
  toggleEl.setAttribute('aria-pressed','false');
  state.isNight = false;

  function getCurrentDistance(){
    try {
      const gcomp = globeChart.getModel().getComponent('globe');
      if(gcomp && typeof gcomp.getViewControl === 'function'){
        const vc = gcomp.getViewControl();
        if(vc && typeof vc.distance === 'number') return vc.distance;
      }
      if(gcomp && gcomp.viewControl && typeof gcomp.viewControl.distance === 'number') return gcomp.viewControl.distance;
      const o = globeChart.getOption();
      if(o && o.globe && o.globe.viewControl && typeof o.globe.viewControl.distance === 'number') return o.globe.viewControl.distance;
    } catch(e){}
    return state.distance || INITIAL_DISTANCE;
  }

  function refresh(){
    // do not set targetCoord here: avoids recentering after user interaction
    state.showPays = !!chkPays.checked;
    state.showTrajets = !!chkTrajets.checked;
    state.showCapitales = !!chkCapitales.checked;
    state.isNight = toggleEl.classList.contains('night');
    state.distance = getCurrentDistance();
    globeChart.setOption(makeOption(state, false));
  }

  // toggle day/night click
  toggleEl.addEventListener('click', ()=>{
    toggleEl.classList.toggle('night');
    const night = toggleEl.classList.contains('night');
    toggleEl.setAttribute('aria-pressed', String(!!night));
    state.isNight = night;
    refresh();
  });

  chkPays.addEventListener('change', ()=>{ refresh(); });
  chkTrajets.addEventListener('change', ()=>{ refresh(); });
  chkCapitales.addEventListener('change', ()=>{ refresh(); });

  // update on user roam (zoom/rotate) but do not recenter
  globeChart.on('georoam', ()=> {
    state.distance = getCurrentDistance();
    // only update capitals visibility or series if needed (but don't recenter)
    // We'll re-render to adapt to new distance if necessary (no big cost)
    globeChart.setOption(makeOption(state, false));
  });

  globeChart.getZr().on('mousewheel', ()=> {
    state.distance = getCurrentDistance();
    globeChart.setOption(makeOption(state, false));
  });

  // ensure nothing else adds stray series: all series are strictly from makeOption

  // debug counts
  console.log('countries lines:', countryLines.length, 'trajets lines:', trajetLines.length, 'capitals:', capitalPoints.length);

})(); // end IIFE
</script>
</body>
</html>
